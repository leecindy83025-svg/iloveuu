<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Finger Magic - 3D Particle Interaction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            height: 100vh;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas { 
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
        }
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
        }
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        .loading.hidden {
            display: none;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #ff3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #fff;
            font-size: 18px;
        }
        .magic-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 48px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            text-shadow: 0 0 20px rgba(255, 51, 102, 0.8);
            transition: opacity 0.5s;
        }
        #cameraStatus {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="threeCanvas"></canvas>
        <video id="webcam" autoplay muted playsinline style="display: none;"></video>
        
        <button class="fullscreen-btn" id="fullscreenBtn" title="Fullscreen">
            ⛶
        </button>
        
        <div class="magic-text" id="magicText"></div>
        
        <div class="instruction" id="instruction">
            Finger Magic: 1 finger = "1", 2 fingers = "2", 3 fingers = "3", 5 fingers = "I ❤️ U", fist = Reset
        </div>
        
        <div id="cameraStatus">Requesting camera access...</div>
        
        <div class="loading" id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing Magic System...</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let particles, particlePositions, particleVelocities, particleAccelerations;
        let particleCount = 15000;
        let targetShape = 'idle';
        let handDetected = false;
        let fingerCount = 0;
        let lastFingerCount = 0;
        let handPosition = { x: 0, y: 0, z: 0 };
        let lastShapeChangeTime = 0;
        let hearts = [], balloons = [], flowers = [];
        
        // Initialize Three.js
        function initThreeJS() {
            console.log("Initializing Three.js...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);
            
            // Create renderer
            const canvas = document.getElementById('threeCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff3366, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x3366ff, 0.6, 50);
            pointLight.position.set(-10, 10, 10);
            scene.add(pointLight);
            
            // Create particle system
            createParticleSystem();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            
            console.log("Three.js initialized successfully");
        }
        
        // Create particle system
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            
            // Initialize arrays
            particlePositions = new Float32Array(particleCount * 3);
            particleVelocities = new Float32Array(particleCount * 3);
            particleAccelerations = new Float32Array(particleCount * 3);
            
            // Random initial positions
            for (let i = 0; i < particleCount * 3; i += 3) {
                const radius = 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                particlePositions[i] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i + 2] = radius * Math.cos(phi);
                
                particleVelocities[i] = 0;
                particleVelocities[i + 1] = 0;
                particleVelocities[i + 2] = 0;
                
                particleAccelerations[i] = 0;
                particleAccelerations[i + 1] = 0;
                particleAccelerations[i + 2] = 0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // Create color array
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i += 3) {
                colors[i] = 0.0;      // R
                colors[i + 1] = 0.8;  // G
                colors[i + 2] = 1.0;  // B
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        // Initialize MediaPipe Hands with SIMPLIFIED camera access
        async function initMediaPipe() {
            console.log("Initializing MediaPipe Hands...");
            const videoElement = document.getElementById('webcam');
            const statusElement = document.getElementById('cameraStatus');
            
            // First, get camera access
            try {
                statusElement.textContent = "Requesting camera permission...";
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: "user"
                    } 
                });
                
                videoElement.srcObject = stream;
                videoElement.width = 640;
                videoElement.height = 480;
                
                statusElement.textContent = "Camera access granted. Loading hand detection...";
                console.log("Camera access granted");
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = resolve;
                });
                
            } catch (error) {
                console.error("Camera error:", error);
                statusElement.textContent = "Camera access denied. Using simulated hand tracking.";
                // Continue without camera - use simulated input
                startSimulatedTracking();
                return;
            }
            
            // Now initialize MediaPipe
            try {
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                hands.onResults((results) => {
                    handleHandResults(results);
                });
                
                // Simple polling for camera frames
                async function processFrame() {
                    if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                        await hands.send({image: videoElement});
                    }
                    requestAnimationFrame(processFrame);
                }
                
                await hands.initialize();
                statusElement.textContent = "Hand detection ready!";
                console.log("MediaPipe Hands initialized");
                
                // Start processing frames
                processFrame();
                
            } catch (error) {
                console.error("MediaPipe error:", error);
                statusElement.textContent = "Hand detection failed. Using simulated input.";
                startSimulatedTracking();
            }
        }
        
        // Simulated hand tracking for when camera fails
        function startSimulatedTracking() {
            console.log("Starting simulated hand tracking");
            const statusElement = document.getElementById('cameraStatus');
            statusElement.textContent = "Using simulated input. Move mouse to control.";
            
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth - 0.5) * 20;
                mouseY = (0.5 - e.clientY / window.innerHeight) * 20;
                
                // Simulate hand position
                handPosition.x = mouseX;
                handPosition.y = mouseY;
                handPosition.z = 0;
            });
            
            // Simulate finger gestures with keyboard
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case '1': handleGestureChange(1); break;
                    case '2': handleGestureChange(2); break;
                    case '3': handleGestureChange(3); break;
                    case '5': handleGestureChange(5); break;
                    case '0': handleGestureChange(0); break;
                }
            });
            
            // Auto cycle through gestures for demo
            let demoIndex = 0;
            const demoGestures = [1, 2, 3, 5, 0];
            
            setInterval(() => {
                handleGestureChange(demoGestures[demoIndex]);
                demoIndex = (demoIndex + 1) % demoGestures.length;
            }, 3000);
        }
        
        // Handle hand detection results
        function handleHandResults(results) {
            handDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            
            if (!handDetected) {
                fingerCount = 0;
                return;
            }
            
            const landmarks = results.multiHandLandmarks[0];
            
            // Update hand position (use wrist)
            handPosition.x = (landmarks[0].x - 0.5) * 20;
            handPosition.y = (0.5 - landmarks[0].y) * 20;
            handPosition.z = landmarks[0].z * 10;
            
            // Count fingers (simplified)
            fingerCount = countFingers(landmarks);
            
            // Handle gesture changes
            if (fingerCount !== lastFingerCount && Date.now() - lastShapeChangeTime > 500) {
                handleGestureChange(fingerCount);
                lastFingerCount = fingerCount;
            }
        }
        
        // Count fingers (simplified version)
        function countFingers(landmarks) {
            const fingerTips = [4, 8, 12, 16, 20]; // Thumb, index, middle, ring, pinky
            const fingerPips = [2, 5, 9, 13, 17]; // Second joints
            
            let count = 0;
            
            for (let i = 0; i < fingerTips.length; i++) {
                const tip = landmarks[fingerTips[i]];
                const pip = landmarks[fingerPips[i]];
                
                // Simplified finger detection
                if (i === 0) { // Thumb
                    if (tip.x < pip.x - 0.05) count++;
                } else { // Other fingers
                    if (tip.y < pip.y - 0.05) count++;
                }
            }
            
            return count;
        }
        
        // Handle gesture changes
        function handleGestureChange(fingers) {
            if (Date.now() - lastShapeChangeTime < 500) return;
            
            lastShapeChangeTime = Date.now();
            
            switch(fingers) {
                case 0: // Fist - Reset
                    targetShape = 'idle';
                    showMagicText("RESET");
                    resetScene();
                    break;
                case 1: // 1 finger - Number 1
                    targetShape = 'number1';
                    showMagicText("1");
                    break;
                case 2: // 2 fingers - Number 2
                    targetShape = 'number2';
                    showMagicText("2");
                    break;
                case 3: // 3 fingers - Number 3
                    targetShape = 'number3';
                    showMagicText("3");
                    break;
                case 5: // 5 fingers - Love effect
                    targetShape = 'iloveyou';
                    createLoveEffect();
                    showMagicText("I ❤️ U");
                    break;
                default:
                    targetShape = 'idle';
            }
        }
        
        // Show magic text
        function showMagicText(text) {
            const magicText = document.getElementById('magicText');
            magicText.textContent = text;
            magicText.style.opacity = 1;
            
            setTimeout(() => {
                magicText.style.opacity = 0;
            }, 1000);
        }
        
        // Create love effect
        function createLoveEffect() {
            createHearts();
            createBalloons();
            createFlowers();
        }
        
        // Create hearts
        function createHearts() {
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                    transparent: true,
                    opacity: 0.9
                });
                
                const heart = new THREE.Mesh(geometry, material);
                heart.position.set(
                    (Math.random() - 0.5) * 15,
                    -10,
                    (Math.random() - 0.5) * 5
                );
                
                hearts.push(heart);
                scene.add(heart);
                
                // Animation
                animateHeart(heart, i);
            }
        }
        
        function animateHeart(heart, delay) {
            setTimeout(() => {
                const startY = heart.position.y;
                const speed = 2 + Math.random() * 2;
                
                function float() {
                    if (!heart.parent) return;
                    
                    heart.position.y += speed * 0.1;
                    heart.rotation.y += 0.02;
                    
                    if (heart.position.y > 20) {
                        scene.remove(heart);
                        const index = hearts.indexOf(heart);
                        if (index > -1) hearts.splice(index, 1);
                    } else {
                        requestAnimationFrame(float);
                    }
                }
                
                float();
            }, delay * 100);
        }
        
        // Create balloons
        function createBalloons() {
            for (let i = 0; i < 15; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.6),
                    transparent: true,
                    opacity: 0.8
                });
                
                const balloon = new THREE.Mesh(geometry, material);
                balloon.position.set(
                    (Math.random() - 0.5) * 10,
                    -10,
                    (Math.random() - 0.5) * 5
                );
                
                balloons.push(balloon);
                scene.add(balloon);
                
                animateBalloon(balloon, i);
            }
        }
        
        function animateBalloon(balloon, delay) {
            setTimeout(() => {
                const speed = 1 + Math.random();
                
                function rise() {
                    if (!balloon.parent) return;
                    
                    balloon.position.y += speed * 0.1;
                    balloon.rotation.y += 0.01;
                    
                    if (balloon.position.y > 20) {
                        scene.remove(balloon);
                        const index = balloons.indexOf(balloon);
                        if (index > -1) balloons.splice(index, 1);
                    } else {
                        requestAnimationFrame(rise);
                    }
                }
                
                rise();
            }, delay * 150);
        }
        
        // Create flowers
        function createFlowers() {
            for (let i = 0; i < 10; i++) {
                const group = new THREE.Group();
                
                // Simple flower representation
                const geometry = new THREE.ConeGeometry(0.2, 0.4, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.8, 1, 0.6),
                    transparent: true,
                    opacity: 0.9
                });
                
                const flower = new THREE.Mesh(geometry, material);
                flower.position.set(
                    (Math.random() - 0.5) * 8,
                    -10,
                    (Math.random() - 0.5) * 4
                );
                
                flowers.push(flower);
                scene.add(flower);
                
                animateFlower(flower, i);
            }
        }
        
        function animateFlower(flower, delay) {
            setTimeout(() => {
                const speed = 1.5 + Math.random();
                
                function float() {
                    if (!flower.parent) return;
                    
                    flower.position.y += speed * 0.1;
                    flower.rotation.y += 0.015;
                    
                    if (flower.position.y > 20) {
                        scene.remove(flower);
                        const index = flowers.indexOf(flower);
                        if (index > -1) flowers.splice(index, 1);
                    } else {
                        requestAnimationFrame(float);
                    }
                }
                
                float();
            }, delay * 200);
        }
        
        // Reset scene
        function resetScene() {
            targetShape = 'idle';
            
            // Clear all effects
            hearts.forEach(heart => scene.remove(heart));
            hearts = [];
            
            balloons.forEach(balloon => scene.remove(balloon));
            balloons = [];
            
            flowers.forEach(flower => scene.remove(flower));
            flowers = [];
        }
        
        // Get target position for particles
        function getTargetPosition(index, total) {
            let x = 0, y = 0, z = 0;
            const time = Date.now() * 0.001;
            const progress = index / total;
            
            switch(targetShape) {
                case 'number1':
                    // Number 1 - simplified shape
                    const angle1 = progress * Math.PI * 2;
                    x = Math.sin(angle1 * 3) * 4;
                    y = Math.cos(angle1 * 3) * 4;
                    break;
                    
                case 'number2':
                    // Number 2 - simplified shape
                    const angle2 = progress * Math.PI * 2;
                    x = Math.sin(angle2 * 4) * 4;
                    y = Math.cos(angle2 * 2) * 4;
                    break;
                    
                case 'number3':
                    // Number 3 - simplified shape
                    const angle3 = progress * Math.PI * 2;
                    x = Math.sin(angle3 * 5) * 4;
                    y = Math.cos(angle3 * 3) * 4;
                    break;
                    
                case 'iloveyou':
                    // I ❤️ U - simplified representation
                    if (progress < 0.33) {
                        // I
                        x = -5;
                        y = 8 - 16 * (progress * 3);
                    } else if (progress < 0.66) {
                        // Heart
                        const t = (progress - 0.33) * 3;
                        const angle = t * Math.PI * 2;
                        x = Math.sin(angle * 3) * 3;
                        y = Math.cos(angle * 2) * 3;
                    } else {
                        // U
                        const t = (progress - 0.66) * 3;
                        x = 5;
                        y = 8 - 16 * t;
                    }
                    break;
                    
                default: // idle
                    // Random distribution in a sphere
                    const radius = 8;
                    const theta = progress * Math.PI * 2;
                    const phi = Math.acos(2 * progress - 1);
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
            }
            
            // Add subtle animation
            x += Math.sin(time * 0.5 + index * 0.001) * 0.2;
            y += Math.cos(time * 0.3 + index * 0.001) * 0.2;
            
            // Hand interaction
            if (handDetected) {
                const dx = x - handPosition.x;
                const dy = y - handPosition.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 5) {
                    x += (x - handPosition.x) * 0.1 / (dist + 0.1);
                    y += (y - handPosition.y) * 0.1 / (dist + 0.1);
                }
            }
            
            return new THREE.Vector3(x, y, z);
        }
        
        // Update physics simulation
        function updatePhysics() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const idx = i / 3;
                
                // Current position
                const currentPos = new THREE.Vector3(
                    positions[i],
                    positions[i + 1],
                    positions[i + 2]
                );
                
                // Target position
                const targetPos = getTargetPosition(idx, particleCount);
                
                // Calculate attraction force
                const attraction = new THREE.Vector3()
                    .subVectors(targetPos, currentPos)
                    .multiplyScalar(0.05);
                
                // Update velocity
                particleVelocities[i] += attraction.x;
                particleVelocities[i + 1] += attraction.y;
                particleVelocities[i + 2] += attraction.z;
                
                // Apply damping
                particleVelocities[i] *= 0.95;
                particleVelocities[i + 1] *= 0.95;
                particleVelocities[i + 2] *= 0.95;
                
                // Update position
                positions[i] += particleVelocities[i];
                positions[i + 1] += particleVelocities[i + 1];
                positions[i + 2] += particleVelocities[i + 2];
                
                // Update colors based on target shape
                let r, g, b;
                switch(targetShape) {
                    case 'number1':
                        r = 0.0; g = 0.8; b = 1.0; break; // Cyan
                    case 'number2':
                        r = 0.2; g = 1.0; b = 0.2; break; // Green
                    case 'number3':
                        r = 1.0; g = 0.5; b = 0.0; break; // Orange
                    case 'iloveyou':
                        r = 1.0; g = 0.2; b = 0.4; break; // Pink
                    default:
                        r = 0.0; g = 0.6; b = 1.0; // Blue
                }
                
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            
            // Gentle camera movement
            const time = Date.now() * 0.001;
            camera.position.x = Math.sin(time * 0.05) * 5;
            camera.position.z = 25 + Math.cos(time * 0.05) * 2;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
        
        // Initialize everything
        async function init() {
            console.log("Starting initialization...");
            
            // Initialize Three.js immediately
            initThreeJS();
            
            // Hide loading screen after a short delay
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('cameraStatus').style.display = 'none';
            }, 2000);
            
            // Start animation loop
            animate();
            
            // Initialize MediaPipe (this might fail, but we have fallback)
            await initMediaPipe();
            
            console.log("Initialization complete!");
        }
        
        // Start when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
