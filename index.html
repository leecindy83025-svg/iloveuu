<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finger Magic - 3D Particle Interaction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646424875/camera_utils.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        #webcam {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            z-index: 100;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 230px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }
        
        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #ff3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #fff;
            font-size: 18px;
            letter-spacing: 2px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
        }
        
        .magic-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 48px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            text-shadow: 0 0 20px rgba(255, 51, 102, 0.8);
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="threeCanvas"></canvas>
        <video id="webcam" autoplay muted playsinline></video>
        
        <button class="fullscreen-btn" id="fullscreenBtn" title="Fullscreen">
            ⛶
        </button>
        
        <div class="magic-text" id="magicText"></div>
        
        <div class="instruction" id="instruction">
            Finger Magic: 1 finger = "1", 2 fingers = "2", 3 fingers = "3", 5 fingers = "I ❤️ U", fist = Reset
        </div>
        
        <div class="loading" id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Magic System...</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let particles, particlePositions, particleVelocities, particleAccelerations;
        let particleCount = 15000;
        let targetShape = 'idle';
        let currentShape = 'idle';
        let handDetected = false;
        let fingerCount = 0;
        let lastFingerCount = 0;
        let handPosition = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let lastHandPosition = null;
        let lastHandTime = 0;
        let lastShapeChangeTime = 0;
        let hearts = [], balloons = [], flowers = [];
        let isResetting = false;
        let cameraControls = { x: 0, y: 0, z: 25 };
        
        // Fix: Initialize CameraUtils globally
        window.Camera = Camera;
        
        // Initialize Three.js
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 30);
            
            // Create camera - ensure text display is complete
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraControls.x, cameraControls.y, cameraControls.z);
            
            // Create renderer
            const canvas = document.getElementById('threeCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff3366, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x3366ff, 0.6, 50);
            pointLight.position.set(-10, 10, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);
            
            // Create particle system
            createParticleSystem();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 2000);
        }
        
        // Create particle system
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            
            // Initialize arrays
            particlePositions = new Float32Array(particleCount * 3);
            particleVelocities = new Float32Array(particleCount * 3);
            particleAccelerations = new Float32Array(particleCount * 3);
            
            // Random initial positions
            for (let i = 0; i < particleCount * 3; i += 3) {
                particlePositions[i] = (Math.random() - 0.5) * 20;
                particlePositions[i + 1] = (Math.random() - 0.5) * 20;
                particlePositions[i + 2] = (Math.random() - 0.5) * 20;
                
                particleVelocities[i] = 0;
                particleVelocities[i + 1] = 0;
                particleVelocities[i + 2] = 0;
                
                particleAccelerations[i] = 0;
                particleAccelerations[i + 1] = 0;
                particleAccelerations[i + 2] = 0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // Create color array
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i += 3) {
                colors[i] = 0.0;      // R
                colors[i + 1] = 0.8;  // G
                colors[i + 2] = 1.0;  // B
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        // Initialize MediaPipe Hands with FIXED camera
        function initMediaPipe() {
            const videoElement = document.getElementById('webcam');
            
            // Fix: Ensure video element is properly configured
            videoElement.width = 640;
            videoElement.height = 480;
            
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults((results) => {
                handleHandResults(results);
            });
            
            // Fix: Create camera with proper error handling
            try {
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        try {
                            await hands.send({image: videoElement});
                        } catch (e) {
                            console.log('Camera frame error:', e);
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start().then(() => {
                    console.log('Camera started successfully');
                }).catch(err => {
                    console.error('Camera error:', err);
                    // Fallback: Use a static camera image
                    document.getElementById('instruction').innerHTML = 
                        'Camera permission needed. Please allow camera access and refresh.';
                });
                
            } catch (error) {
                console.error('Camera initialization error:', error);
            }
        }
        
        // Handle hand detection results
        function handleHandResults(results) {
            handDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            
            if (!handDetected) {
                fingerCount = 0;
                return;
            }
            
            const landmarks = results.multiHandLandmarks[0];
            
            // Update hand position
            handPosition.x = (landmarks[0].x - 0.5) * 20;
            handPosition.y = (0.5 - landmarks[0].y) * 20;
            handPosition.z = landmarks[0].z * 10;
            
            // Calculate hand speed
            calculateHandSpeed(landmarks[0]);
            
            // Count fingers
            fingerCount = countFingers(landmarks);
            
            // Handle gesture changes
            if (fingerCount !== lastFingerCount && Date.now() - lastShapeChangeTime > 500) {
                handleGestureChange(fingerCount);
                lastFingerCount = fingerCount;
            }
        }
        
        // Calculate hand speed
        function calculateHandSpeed(wristLandmark) {
            const now = Date.now();
            
            if (lastHandPosition && lastHandTime > 0) {
                const timeDiff = (now - lastHandTime) / 1000;
                if (timeDiff > 0) {
                    const dx = wristLandmark.x - lastHandPosition.x;
                    const dy = wristLandmark.y - lastHandPosition.y;
                    const dz = wristLandmark.z - lastHandPosition.z;
                    
                    handSpeed = Math.sqrt(dx*dx + dy*dy + dz*dz) / timeDiff;
                }
            }
            
            lastHandPosition = {x: wristLandmark.x, y: wristLandmark.y, z: wristLandmark.z};
            lastHandTime = now;
        }
        
        // Count fingers
        function countFingers(landmarks) {
            const fingerTips = [4, 8, 12, 16, 20];
            const fingerPips = [2, 5, 9, 13, 17];
            
            let count = 0;
            
            for (let i = 0; i < fingerTips.length; i++) {
                const tip = landmarks[fingerTips[i]];
                const pip = landmarks[fingerPips[i]];
                
                if (i === 0) {
                    // Thumb
                    if (tip.x < pip.x) count++;
                } else {
                    // Other fingers
                    if (tip.y < pip.y) count++;
                }
            }
            
            return count;
        }
        
        // Handle gesture changes
        function handleGestureChange(fingers) {
            if (isResetting) return;
            
            lastShapeChangeTime = Date.now();
            
            switch(fingers) {
                case 0: // Fist - Reset
                    resetScene();
                    break;
                case 1: // 1 finger - Number 1
                    targetShape = 'number1';
                    showMagicText("1");
                    break;
                case 2: // 2 fingers - Number 2
                    targetShape = 'number2';
                    showMagicText("2");
                    break;
                case 3: // 3 fingers - Number 3
                    targetShape = 'number3';
                    showMagicText("3");
                    break;
                case 5: // 5 fingers - Love effect
                    targetShape = 'iloveyou';
                    createLoveEffect();
                    showMagicText("I ❤️ U");
                    break;
                default:
                    targetShape = 'idle';
            }
        }
        
        // Show magic text
        function showMagicText(text) {
            const magicText = document.getElementById('magicText');
            magicText.textContent = text;
            magicText.style.opacity = 1;
            
            setTimeout(() => {
                magicText.style.opacity = 0;
            }, 1000);
        }
        
        // Create love effect
        function createLoveEffect() {
            createHearts();
            createBalloons();
            createFlowers();
        }
        
        // Create hearts
        function createHearts() {
            for (let i = 0; i < 30; i++) {
                const heart = createHeart();
                hearts.push(heart);
                scene.add(heart);
                
                // Animation
                animateHeart(heart, i);
            }
        }
        
        function createHeart() {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            
            // Draw heart shape
            heartShape.bezierCurveTo(0, 0.5, -0.5, 1, -0.25, 1.5);
            heartShape.bezierCurveTo(0, 1.8, 0.25, 1.5, 0.5, 1.5);
            heartShape.bezierCurveTo(0.75, 1.5, 1, 1.8, 1.25, 1.5);
            heartShape.bezierCurveTo(1.5, 1, 2, 0.5, 2, 0);
            heartShape.bezierCurveTo(2, -0.5, 1, -1, 0, -1.5);
            heartShape.bezierCurveTo(-1, -1, -2, -0.5, -2, 0);
            heartShape.bezierCurveTo(-2, 0.5, -1.5, 1, -1.25, 1.5);
            heartShape.bezierCurveTo(-1, 1.8, -0.75, 1.5, -0.5, 1.5);
            heartShape.bezierCurveTo(-0.25, 1.5, 0, 1.8, 0, 2);
            
            const geometry = new THREE.ShapeGeometry(heartShape);
            geometry.scale(0.05, 0.05, 0.05);
            
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                transparent: true,
                opacity: 0.9
            });
            
            const heart = new THREE.Mesh(geometry, material);
            heart.position.set(
                (Math.random() - 0.5) * 20,
                -10,
                (Math.random() - 0.5) * 10
            );
            
            return heart;
        }
        
        function animateHeart(heart, delay) {
            setTimeout(() => {
                const startY = heart.position.y;
                const amplitude = 15 + Math.random() * 10;
                const speed = 0.5 + Math.random() * 0.5;
                const rotationSpeed = Math.random() * 0.02;
                
                function float() {
                    if (!heart.parent) return;
                    
                    const time = Date.now() * 0.001;
                    heart.position.y = startY + Math.sin(time * speed) * amplitude;
                    heart.rotation.y += rotationSpeed;
                    
                    if (heart.position.y > 20) {
                        scene.remove(heart);
                        const index = hearts.indexOf(heart);
                        if (index > -1) hearts.splice(index, 1);
                    } else {
                        requestAnimationFrame(float);
                    }
                }
                
                float();
            }, delay * 50);
        }
        
        // Create balloons
        function createBalloons() {
            for (let i = 0; i < 20; i++) {
                const balloon = createBalloon();
                balloons.push(balloon);
                scene.add(balloon);
                
                animateBalloon(balloon, i);
            }
        }
        
        function createBalloon() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random(), 1, 0.6),
                transparent: true,
                opacity: 0.8
            });
            
            const balloon = new THREE.Mesh(geometry, material);
            balloon.position.set(
                (Math.random() - 0.5) * 15,
                -10,
                (Math.random() - 0.5) * 10
            );
            
            // Balloon string
            const lineGeometry = new THREE.CylinderGeometry(0.01, 0.01, 2);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.y = -1;
            balloon.add(line);
            
            return balloon;
        }
        
        function animateBalloon(balloon, delay) {
            setTimeout(() => {
                const startY = balloon.position.y;
                const speed = 0.3 + Math.random() * 0.3;
                const rotationSpeed = Math.random() * 0.01;
                
                function rise() {
                    if (!balloon.parent) return;
                    
                    balloon.position.y += speed;
                    balloon.rotation.y += rotationSpeed;
                    
                    if (balloon.position.y > 25) {
                        scene.remove(balloon);
                        const index = balloons.indexOf(balloon);
                        if (index > -1) balloons.splice(index, 1);
                    } else {
                        requestAnimationFrame(rise);
                    }
                }
                
                rise();
            }, delay * 100);
        }
        
        // Create flowers
        function createFlowers() {
            for (let i = 0; i < 15; i++) {
                const flower = createFlower();
                flowers.push(flower);
                scene.add(flower);
                
                animateFlower(flower, i);
            }
        }
        
        function createFlower() {
            const group = new THREE.Group();
            
            // Petals
            const petalGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const petalMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.8, 1, 0.6),
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 8; i++) {
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.rotation.z = (i / 8) * Math.PI * 2;
                petal.position.y = 0.1;
                group.add(petal);
            }
            
            // Flower center
            const centerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.9
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            group.add(center);
            
            group.position.set(
                (Math.random() - 0.5) * 12,
                -10,
                (Math.random() - 0.5) * 8
            );
            
            return group;
        }
        
        function animateFlower(flower, delay) {
            setTimeout(() => {
                const startY = flower.position.y;
                const speed = 0.4 + Math.random() * 0.4;
                const rotationSpeed = Math.random() * 0.015;
                
                function float() {
                    if (!flower.parent) return;
                    
                    flower.position.y += speed;
                    flower.rotation.y += rotationSpeed;
                    
                    if (flower.position.y > 20) {
                        scene.remove(flower);
                        const index = flowers.indexOf(flower);
                        if (index > -1) flowers.splice(index, 1);
                    } else {
                        requestAnimationFrame(float);
                    }
                }
                
                float();
            }, delay * 150);
        }
        
        // Reset scene
        function resetScene() {
            isResetting = true;
            
            targetShape = 'idle';
            
            // Clear all effects
            hearts.forEach(heart => scene.remove(heart));
            hearts = [];
            
            balloons.forEach(balloon => scene.remove(balloon));
            balloons = [];
            
            flowers.forEach(flower => scene.remove(flower));
            flowers = [];
            
            // Reset particle positions
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;
                positions[i + 1] = (Math.random() - 0.5) * 20;
                positions[i + 2] = (Math.random() - 0.5) * 20;
                
                particleVelocities[i] = 0;
                particleVelocities[i + 1] = 0;
                particleVelocities[i + 2] = 0;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            setTimeout(() => {
                isResetting = false;
            }, 500);
        }
        
        // Get target position
        function getTargetPosition(index, total) {
            let x = 0, y = 0, z = 0;
            const time = Date.now() * 0.001;
            const progress = index / total;
            
            switch(targetShape) {
                case 'number1':
                    // Number 1
                    if (progress < 0.2) {
                        x = -3 + 6 * (progress / 0.2);
                        y = 5;
                    } else if (progress < 0.5) {
                        const t = (progress - 0.2) / 0.3;
                        x = 0;
                        y = 5 - 10 * t;
                    } else {
                        const t = (progress - 0.5) / 0.5;
                        x = -3 + 6 * t;
                        y = -5;
                    }
                    break;
                    
                case 'number2':
                    // Number 2
                    if (progress < 0.3) {
                        const t = progress / 0.3;
                        const angle = Math.PI * t * 0.8;
                        x = Math.cos(angle) * 4 - 2;
                        y = Math.sin(angle) * 2 + 3;
                    } else if (progress < 0.6) {
                        const t = (progress - 0.3) / 0.3;
                        x = 2 - 8 * t;
                        y = 3 - 5 * t;
                    } else {
                        const t = (progress - 0.6) / 0.4;
                        const angle = Math.PI * t * 0.8 + Math.PI * 0.8;
                        x = Math.cos(angle) * 4 - 2;
                        y = Math.sin(angle) * 2 - 2;
                    }
                    break;
                    
                case 'number3':
                    // Number 3
                    if (progress < 0.5) {
                        const t = progress / 0.5;
                        const angle = Math.PI * t * 1.5;
                        x = Math.cos(angle) * 3;
                        y = Math.sin(angle) * 2 + 2;
                    } else {
                        const t = (progress - 0.5) / 0.5;
                        const angle = Math.PI * t * 1.5 + Math.PI * 1.5;
                        x = Math.cos(angle) * 3;
                        y = Math.sin(angle) * 2 - 2;
                    }
                    break;
                    
                case 'iloveyou':
                    // I ❤️ U
                    if (progress < 0.1) {
                        // I
                        const t = progress / 0.1;
                        x = -6;
                        y = 4 - 8 * t;
                    } else if (progress < 0.3) {
                        // Heart
                        const t = (progress - 0.1) / 0.2;
                        const angle = t * Math.PI * 2;
                        const scale = 3;
                        x = scale * 16 * Math.pow(Math.sin(angle), 3) * 0.03;
                        y = scale * (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * 0.03;
                    } else if (progress < 0.8) {
                        // U
                        const t = (progress - 0.3) / 0.5;
                        if (t < 0.5) {
                            x = 3;
                            y = 4 - 8 * (t * 2);
                        } else {
                            const u = (t - 0.5) * 2;
                            const angle = u * Math.PI;
                            x = 3 + Math.cos(angle + Math.PI) * 3;
                            y = -4 + Math.sin(angle + Math.PI) * 3;
                        }
                    } else {
                        // Random particles
                        const angle = progress * Math.PI * 2;
                        const radius = 8;
                        x = radius * Math.cos(angle) * Math.sin(progress * Math.PI);
                        y = radius * Math.sin(angle) * Math.sin(progress * Math.PI);
                        z = radius * Math.cos(progress * Math.PI);
                    }
                    break;
                    
                default: // idle
                    // Random distribution
                    const angle = progress * Math.PI * 2;
                    const radius = 10;
                    x = radius * Math.cos(angle) * Math.sin(progress * Math.PI);
                    y = radius * Math.sin(angle) * Math.sin(progress * Math.PI);
                    z = radius * Math.cos(progress * Math.PI);
            }
            
            // Add subtle animation
            x += Math.sin(time * 0.5 + index * 0.001) * 0.1;
            y += Math.cos(time * 0.3 + index * 0.001) * 0.1;
            
            return new THREE.Vector3(x, y, z);
        }
        
        // Update physics simulation
        function updatePhysics() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const idx = i / 3;
                
                // Current position
                const currentPos = new THREE.Vector3(
                    positions[i],
                    positions[i + 1],
                    positions[i + 2]
                );
                
                // Target position
                const targetPos = getTargetPosition(idx, particleCount);
                
                // Calculate attraction
                const attraction = new THREE.Vector3()
                    .subVectors(targetPos, currentPos)
                    .multiplyScalar(0.08);
                
                // Hand interaction
                let handForce = new THREE.Vector3(0, 0, 0);
                if (handDetected) {
                    const handVec = new THREE.Vector3(handPosition.x, handPosition.y, handPosition.z);
                    const distToHand = currentPos.distanceTo(handVec);
                    
                    if (distToHand < 4) {
                        const repulse = new THREE.Vector3()
                            .subVectors(currentPos, handVec)
                            .normalize()
                            .multiplyScalar(0.2 / (distToHand + 0.1));
                        handForce.add(repulse);
                        
                        if (handSpeed > 0.3) {
                            const storm = new THREE.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                                Math.random() - 0.5
                            ).normalize().multiplyScalar(handSpeed * 0.03);
                            handForce.add(storm);
                        }
                    }
                }
                
                // Total acceleration
                particleAccelerations[i] = attraction.x + handForce.x;
                particleAccelerations[i + 1] = attraction.y + handForce.y;
                particleAccelerations[i + 2] = attraction.z + handForce.z;
                
                // Update velocity
                particleVelocities[i] += particleAccelerations[i];
                particleVelocities[i + 1] += particleAccelerations[i + 1];
                particleVelocities[i + 2] += particleAccelerations[i + 2];
                
                // Damping
                particleVelocities[i] *= 0.96;
                particleVelocities[i + 1] *= 0.96;
                particleVelocities[i + 2] *= 0.96;
                
                // Update position
                positions[i] += particleVelocities[i];
                positions[i + 1] += particleVelocities[i + 1];
                positions[i + 2] += particleVelocities[i + 2];
                
                // Update colors
                let r, g, b;
                switch(targetShape) {
                    case 'number1':
                        r = 0.0; g = 0.8; b = 1.0; // Cyan
                        break;
                    case 'number2':
                        r = 0.2; g = 1.0; b = 0.2; // Green
                        break;
                    case 'number3':
                        r = 1.0; g = 0.5; b = 0.0; // Orange
                        break;
                    case 'iloveyou':
                        r = 1.0; g = 0.2; b = 0.4; // Pink
                        break;
                    default:
                        r = 0.0; g = 0.6; b = 1.0; // Blue
                }
                
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            
            // Camera animation
            const time = Date.now() * 0.001;
            camera.position.x = Math.sin(time * 0.1) * 25;
            camera.position.z = Math.cos(time * 0.1) * 25;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
        
        // Initialize
        function init() {
            initThreeJS();
            initMediaPipe();
            animate();
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
